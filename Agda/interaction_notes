===================================
Interaction with Emacs - Agda notes 
===================================

Global view:
  agda-mode in Emacs opens a helper buffer called *ghci* and loads the Agda package in it.
    This is achieved using the haskell-mode. 
  Whenever the user issues a command (reloads the file, asks for the type/normal form of the
  given term etc) the emacs mode builds call to the appriopriate function.
    For example, loading the file builds a call to the 'cmd_load' function from Agda.Interaction.GhciTop.
  The built command is evaluated by ghci and emacs awaits for the reply. Haskell code prints the reply on
  the stdout, formatted as lisp data. agda-mode reads this answer and displays it to the user.

===================
Example interaction
===================

1. User opens a new file called Test2.agda in emacs.

[ghci>     - command send]
[no prefix - answer/reply]

ghci> :set -package Agda-2.3.1
ghci> :mod + Agda.Interaction.GhciTop
ghci> ioTCM "/home/wjzz/Test2.agda" Nothing ( cmd_write_highlighting_info "/home/wjzz/Test2.agda" "/tmp/agda2-mode3058SBR" )

agda2_mode_code (agda2-status-action "")

2. User types some code and loads it - the code is incorrect

ghci> ioTCM "/home/wjzz/Test2.agda" (Just "/tmp/agda2-mode3058sVd") ( cmd_load "/home/wjzz/Test2.agda" [".", "/home/wjzz/Agda-dev/Edge/std-lib/lib/src"] )

agda2_mode_code (agda2-status-action "")
Checking Test2 (/home/wjzz/Test2.agda).
agda2_mode_code (agda2-info-action "*Error*" "/home/wjzz/Test2.agda:6,6-11
                                              Missing type signature for False")
agda2_mode_code (annotation-goto '("/home/wjzz/Test2.agda" . 81))
agda2_mode_code (agda2-status-action "")
*** Exception: ExitFailure 1


* Effect: the wrong part is highlighted in red and the cursor in move to the offending part.
        Also, the error message appears in a new buffer at the bottom.


3. User fixes the code and reloads it.

ghci> ioTCM "/home/wjzz/Test2.agda" (Just "/tmp/agda2-mode3058fSL") ( cmd_load "/home/wjzz/Test2.agda" [".", "/home/wjzz/Agda-dev/Edge/std-lib/lib/src"] )

agda2_mode_code (agda2-status-action "")
Checking Test2 (/home/wjzz/Test2.agda).
Finished Test2.
agda2_mode_code (agda2-status-action "Checked")
agda2_mode_code (agda2-info-action "*All Goals*" "")
agda2_mode_code (agda2-goals-action '())


* Effect: the code is syntax highlighted (lots of colors)


4. User defines a function and leaves a single goal inside.

ghci> ioTCM "/home/wjzz/Test2.agda" (Just "/tmp/agda2-mode3058T7j") ( cmd_load "/home/wjzz/Test2.agda" [".", "/home/wjzz/Agda-dev/Edge/std-lib/lib/src"] )

agda2_mode_code (agda2-status-action "")
Checking Test2 (/home/wjzz/Test2.agda).
Finished Test2.
agda2_mode_code (agda2-status-action "Checked")
agda2_mode_code (agda2-info-action "*All Goals*" "?0 : True

")
agda2_mode_code (agda2-goals-action '(0))


* Effect: the given list of goals is displayed in the buffer at the bottom.


5. User asks for automatic case split.

ghci> ioTCM "/home/wjzz/Test2.agda" Nothing ( cmd_make_case 0 (Range [Interval (Pn (Just (mkAbsolute "/home/wjzz/Test2.agda")) 181 13 11) (Pn (Just (mkAbsolute "/home/wjzz/Test2.agda")) 182 13 12)]) "b" )

agda2_mode_code (last . (agda2-make-case-action '("foo true = ?" "foo false = ?")))
agda2_mode_code (agda2-goals-action '(0))

ghci> ioTCM "/home/wjzz/Test2.agda" (Just "/tmp/agda2-mode3058uXr") ( cmd_load "/home/wjzz/Test2.agda" [".", "/home/wjzz/Agda-dev/Edge/std-lib/lib/src"] )

agda2_mode_code (agda2-status-action "")
Checking Test2 (/home/wjzz/Test2.agda).
Finished Test2.
agda2_mode_code (agda2-status-action "")
agda2_mode_code (agda2-info-action "*All Goals*" "?0 : Bool
?1 : Bool

")
agda2_mode_code (agda2-goals-action '(0 1))


* Effect: new code is inserted.


====================
Emacs files overview
====================

List of files:

* agda2.el [~ 20 loc]
  - comments say this should be run before the first Agda file loaded
  - it looks a bit fishy, some of the code is duplicated in agda2-mode.el
  - some autoload instructions

* agda2-mode.el [~ 1200 loc]
  - derives the major mode, defines configuration variables
  - defines functions for communication with the Haskell side

* agda-input.el [~ 800 loc]
  - defines the translation lists for the input method [~ 450 loc]

* agda2-abbrevs.el [~ 100 loc]
  - defines example abbrevs (template-like stuff) for editing Agda code

* agda2-highlight.el [~ 400 loc]
  - syntactic highlighting of Agda code, based on the info generated by the Haskell side
  - it only defines and documents the colors, the whole work is done by the 'annotation' module

* annotation.el [~ 200 loc]
  - defines functions for loading files with annotation info (annotation-load-file)
    and for applying the loaded annotations (annotation-annotate)

* eri.pl [~ 200 loc]
  - ERI = enhanced relative indentation
  - defines functions for calculating sensible indentation points
  - well documented!

=====================
Haskell code overview
=====================








